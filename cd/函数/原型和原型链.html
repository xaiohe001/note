<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 每一个引用类型都有一个构造函数
        function Person(name, age) {
            this.name = name;
            this.age = age;
        }
        // 每一个构造函数都有一个 prototype 属性,这个属性指向的是 原型对象
        // Person.prototype 就是一个原型对象
        // 在原型对象上 添加一个 address 属性
        // 原型对象的属性和方法是共享的
        Person.prototype.address = '中原地区';

        var person1 = new Person('xiaoqiu', 16); //通过 new 操作符 实例化 一个对象
        var person2 = new Person('xiaoliu', 16); //通过 new 操作符 实例化 一个对象
        console.log(person1.address, person1.name, person1.age);
        console.log(person1.address, person1);
        person1.address = '华北地区'; // 给当前实例 添加方法,自己独有的
        console.log(person1.address, person1);
        console.log(person2.address, person2);
        console.log(person1.address); // 华北地区
        //// 当我们去找某个引用类型(当前实例)上的属性和方法时,他会在 自身 上去找,如果有直接读取结束;如果没有,会沿着 构造函数的 prototype 属性指向的 原型对象 去找, (当前实例上的一个 _proto_ 指向的原型对象去找),如果有属性指向 则读取其值
    </script>
</body>

</html>