###  1. this的不同应用场景，如何取值？

- `this取什么样的值 是在函数执行的时候被确定的 不是在函数定义的时候被确定的`

- 作为普通函数被调用

  ​	`this指向window`

- 使用 call apply bind

  ​	`call 一调用就执行`

  ​	`bind 会返回一个新的函数去执行 再重新执行这个函数`

- 作为构造函数被调用

   `this指向新的对象(new会改变this的指向)`

- 作为对象方法被调用

  ​	`返回当前对象`

- 在 class 方法中调用

  ​	`this指的是当前创建的实例`

- 箭头函数

   `setTimout(function(){`

  ​	//  普通函数

  ​	//  this === window

  `})`

  `setTimeout(()=>{`

  ​	//  箭头函数  取值 是取上级作用域的this的值

  ​	//  this  即当前对象

  `})`

### 2. 手写bind函数







### 3. 实际开发中闭包的应用场景，举例说明

- 场景: 参数传递
- 封闭作用域

- 场景: 作用域链
  - 嵌套之间的函数会形成作用域链,每次对变量的访问实际上都是对整条作用域链的遍历查找,先查找最近的作用域,最后在查找全局作用域,如果在某个作用域找到了就会结束本次查找过程

```js
//作用域链
var num = 3;
(function () {
  (function () {
    (function () {
      (function () {
        (function () {
          var num=2;
          console.log(num);
        })();
      })();
    })();
  })();
})();//2  是从里往外查找
```



### 4. 作用域

- 全局作用域 
- 函数作用域
- 块级作用域（ES6新增）

​		

### 5. 列表转化为数组

> arguments  获取函数所有的参数

- `Array.prototype.slice.call(arguments)`

### 6. 同步和异步的区别是什么？

- 同步：一般指的是在代码运行的过程中，从上到下逐步运行代码，每一部分代码运行完成之后，下面的代码才能开始运行

- 异步：指的是当我们需要一些代码在执行的时候不会影响其他代码的执行，也就是在执行代码的同时，可以进行其他的代码的执行，不用等待代码执行完成之后才执行之后的代码，就像我们人一样，可以一边看电视剧一边吃东西一样，互不干扰，这种方式就是异步。

- 而在前端开发中常见的异步一般常见的包括：setTimeout，setInterval，ajax。

  setTimeout是定时延时运行函数，只执行一次

  setInterval也是定时延时函数，但是这个函数本身可以一直执行，不会停止，除非把它清除。

- ajax是前端常用的和后台进行异步交互数据的请求方式，其实它本身也包括同步和异步，同步的就是由代码从上到下顺序执行，而异步的ajax是我们发送请求到服务器之后，只需要在监听服务器的响应即可，不用等到请求结束在执行其他的代码，这就是异步ajax。


### 7. 手写用promise加载一张图片



### 8. 前端使用异步的场景有哪些？

- 网络请求，如Ajax图片加载
- 定时任务，如setTimeout setInterval

### 9. promise中三种状态，如何变化？

- pending状态 -等待，不会触发then和catch
- fulfilled状态-已完成
- rejected状态-已拒绝，会触发后续的catch回调函数
- resolved状态-已完成，会触发后续的then回调函数
  - promise和setTimeout执行顺序
    - promise要比setTimeout先执行

### 10. flex的三个属性值

- flex-grow
- flex-shrink
- flex-basis

### 11. 请描述event loop（事件循环/事件轮询）的机制，可画图

- js是单线程运行的
- 异步要基于回调来实现

- event loop就是异步回调的实现原理

### 12. 什么是宏任务和微任务，两者有什么区别？

- 两者都是异步
- 为什么和定时器有关的任务是宏任务?
  - 因为计时是实时的,他一定不能被阻塞,所以定时器被设计在另一个进程中被管理,所以,定时器任务会有进程的切换,所以只能是宏任务
- 微任务在执行时,它能获取到任务外的上下文
- 宏任务在执行时,他不能获取到任务外的上下文
- 微任务和宏任务执行顺序
  - 因为微任务不需要执行上下文(这里指的是资源的切换),所以他可以在一次上下文切换间隔中吧所有的微任务都做掉
  - 而宏任务因为需要切换上下文,所以他会慢一点执行
  - 所以会先执行已注册的微任务,然后执行宏任务
  - 这样,就相当做了一次上下文的切换,如果在此期间,又有型的微任务或宏任务被注册了,就不断重复上面的这个流程

### 13. js如何执行

- 从前到后，一行一行执行
- 如果某一行执行报错，则停止下面代码的执行
- 先把同步代码执行完，再执行异步

### 14.  防抖节流区别

- 防抖:在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

- 节流:规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

  

- 函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。

- 函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。

  - debounce
    - search搜索联想，用户在不断输入值时，用防抖来节约请求资源。
    - window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次
  - throttle
    - 鼠标不断点击触发，mousedown(单位时间内只触发一次)
    - 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断

### 15. 闭包优缺点

- **闭包就是能够读取其他函数内部变量的函数。**

- 闭包就是能够读取其他函数内部变量的函数,说白了闭包就是个函数,只不过是处于其他函数内部而已

- **三大特性：**

  \- 函数嵌套函数。
  \- 函数内部可以引用外部的参数和变量。
  \- 参数和变量不会被垃圾回收机制回收。

  **优点：**

  \- 希望一个变量长期存储在内存中。
  \- 避免全局变量的污染。
  \- 私有成员的存在。

  **缺点：**

  \- 常驻内存，增加内存使用量。
  \- 使用不当会很容易造成内存泄露。

### 16. vue双向绑定的理解

- vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的
- 我们已经知道实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令（如v-model，v-on）对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。
- **因此接下去我们执行以下3个步骤，实现数据的双向绑定：**
  - （1）实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。
  - （2）实现一个订阅者Watcher，每一个Watcher都绑定一个更新函数，watcher可以收到属性的变化通知并执行相应的函数，从而更新视图。
  - （3）实现一个解析器Compile，可以扫描和解析每个节点的相关指令（v-model，v-on等指令），如果节点存在v-model，v-on等指令，则解析器Compile初始化这类节点的模板数据，使之可以显示在视图上，然后初始化相应的订阅者（Watcher）。

### 17. 重绘和回流理解

**回流必定会发生重绘，重绘不一定会引发回流。**

- 重绘:由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如`outline`, `visibility`, `color`、`background-color`等，重绘的代价是高昂的，因为浏览器必须验证DOM树上其他节点元素的可见性。
- 回流:回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及DOM中紧随其后的节点、祖先节点元素的随后的回流。

### 18. get post区别

- GET请求长度最多1024kb，POST对请求数据没有限制
- POST比GET安全性要高

### 19. react setState是同步还是异步

- 在组件生命周期或React合成事件中，setState是异步；在setTimeout或者原生dom事件中，setState是同步。

### 20. == 和 === 区别

- `==`操作符会先将两边的值进行强制类型转换再比较是否相等，而`===`操作符不会进行类型转换。`==`操作符只要求比较两个值是否相等，而`===`操作符不仅要求值相等，而且要求类型相同。`!=`和`!==`的区别也是类似的，`!=`号会做强制类型转换，而`!==`不会。

- ```js
  // true
  55 == '55'
  // false
  55 === '55'
  ```

- ```js
  // false
  NaN == NaN
  // false
  NaN === NaN
  ```

- ```js
  // true
  null == undefined
  // false
  null === undefined
  ```

### 21. 原型和原型链

- 每个对象都有一个`__proto__`，它指向它的`prototype`原型对象，而`prototype`原型对象又具有一个自己的`prototype`原型对象，就这样层层往上直到一个对象的原型`prototype`为`null`

### 22. 事件委托

- 事件委托就是利用事件冒泡,只指定一个事件处理程序,就可以管理某一类型的所有事件. 将事件加到父元素或者祖先元素上触发执行效果,打个比方：一个 button 对象，本来自己需要监控自身的点击事件，但是自己不来 监控这个点击事件，让自己的父节点来监控自己的点击事件。

  - 好处: 提高性能

- dom事件流的触发先后的顺序为: 先捕获再冒泡

- 事件冒泡: 子元素事件的触发会影响到父元素事件 自下而上冒泡  开启事件冒泡 `addEventListener(eventName,handle,false||true)`

  `removeEventListener(eventName,handle,false||true)`

- 事件捕获: 父元素的事件会影响到子元素的事件   开启事件捕获 `element.addEventListener(eventName,handler,true)`

- 阻止冒泡: e.stopPropagation()

### 23. 判断一个JavaScript变量是array还是Object

- 如果用typeof来检查该变量,不论是array还是Object,都将返回'Object'.

  - instanceof操作符

    ```js
    var arr = [1,2,3,1]; 
    alert(arr instanceof Array); // true
    ```

  - 对象的constructor属性

    ```js
    var arr = [1,2,3,1]; 
    alert(arr.constructor === Array); // true 
    ```

    

- Array.isArray()方法

  ```js
  var arr = []
  var obj = []
  Array.isArray(arr) // true
  Array.isArray(obj) // false
  ```

- Object.prototype.toString.call()方法

![img](https://pic3.zhimg.com/80/v2-2232146e3e24e2b4e1aec9cc0de6bc8a_720w.jpg)

### 24. set数据结构

- 属性和方法

  - size 数据的长度
  - add() 添加某个值,返回Set解构本身
  - delete() 删除某一个值,返回一个布尔值,表示删除是否成功
  - has() 查找某条数据,返回一个布尔值
  - clear() 清除所有成员,没有返回值

  ```js
  var arr = [1,1,2,3,5,1,2,6,6,5]
  var sets = new Set(arr)
  console.log(sets) // 1,2,3,5,6
  
  console.log(sets.size) // 5
  console.log(sets.add(4)) // [1,2,3,4,5,6]
  console.log(sets.delete(4)) // true
  console.log(sets.has(4)) // false
  console.log(sets.clear())
  ```

### 25. 